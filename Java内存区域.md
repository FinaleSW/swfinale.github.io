Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途以及创建、销毁的时间。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200709185341551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZpbmFsZVN3,size_16,color_FFFFFF,t_70#pic_center)

## 线程私有区域

#### 程序计数器

- 一块较小的内存空间
- 为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响
- 如果线程正在执行一个Java方法，则记录正在执行的虚拟机字节码指令的地址
- 如果正在执行Native方法，则值为空（Undefined）
- 唯一一个在《Java虚拟机规范》中没有任何`OutOfMemoryError`情况的区域

#### 虚拟机栈

- 虚拟机栈的生命周期与线程相同
  - 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息
  - 每一个方法被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常
- 如果Java虚拟机栈容量可以动态扩展，当栈扩展无法申请到足够的内存会抛出`OutOfMemoryError`异常

##### 局部变量表

- 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`）、对象引用（引用指针或句柄）
- 局部变量所需的内存空间在编译期间完成分配
  - 当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的

#### 本地方法栈

- 与虚拟机栈的区别只是虚拟机栈为执行Java方法（字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务

## 线程共享区域

#### 堆

- 虚拟机所管理的内存中最大的一块
- 被所有线程共享，在虚拟机启动时创建
- 此内存区域的唯一目的就是存放对象实例
- Java堆是垃圾收集器管理的内存区域，也被称作“GC堆”
- 从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB）
- Java堆既可以被实现成固定大小的，也可以是可扩展的
  - 当前主流的Java虚拟机都是按照可扩展来实现的（通过参数`-Xmx`和`-Xms`设定）
  - 如果Java堆中没有内存完成实例分配，又无法再扩展时，会抛出`OutOfMemoryError`异常

#### 方法区

- 用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
- 和Java堆一样不需要连续的内存
- 可以选择固定大小或可扩展
- 可以选择不实现垃圾回收
  - 垃圾收集行为在方法区是比较少见的
  - 该区域的内存回收目标主要是针对常量池的回收和对类型的卸载
- 如果方法区无法满足新的内存分配需求时，将抛出`OutOfMemoryError`异常

#### 运行时常量池

- 常量池表：用于存放编译期生成的各种字面量和符号引用
  - 一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中
  - **动态性**：Java语言并不要求常量一定只有编译期才能产生
    - 运行期间也可以将新的常量放入常量池
    - 如`String`类的`intern()`方法

#### 直接内存

- 是在Java堆外的、直接向系统申请的内存空间
- 通常访问直接内存的速度会优于Java堆
- 出于性能的考虑，读写频繁的场合会考虑使用直接内存
- 大小不会接受限于Xmx指定的最大堆大小
- Java堆+直接内存的和小于操作系统最大内存



参考文献：《深入理解Java虚拟机》
